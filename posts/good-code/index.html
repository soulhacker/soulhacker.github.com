<!doctype html>

<html lang="en-us">

<head>
  <title>什么是好的代码 - Paradigm X</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="The HTML5 Herald" />
<meta name="author" content="[Neo Lee]" /><meta property="og:url" content="/posts/good-code/">
  <meta property="og:site_name" content="Paradigm X">
  <meta property="og:title" content="什么是好的代码">
  <meta property="og:description" content="本文将讨论一个简单又困难的命题：好代码的标准。注意，现在是 AI Coding 的时代，所以我们的命题自然要考虑 AI 写出的代码以及 AI 写代码的过程。
我们将使用一种模仿数学公理体系的表述方式来进行分析，以便于我们自始至终明确区分“确定的结论”和“有待验证的判断”。当然，目前我们还做不到真正数学级的严谨，但这件事实在太过重要，所以我们可以先接受这种“近似严谨”，再不断迭代优化它。
为了让分析的过程更容易理解，我们会先给出“前 AI Coding 时代”的共识（定义和公理），然后分析在当下有哪些公理依然成立，而哪些已经动摇甚至被颠覆。">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-11T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-01-11T23:16:12+08:00">
    <meta property="article:tag" content="Programming">


  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="什么是好的代码">
  <meta name="twitter:description" content="本文将讨论一个简单又困难的命题：好代码的标准。注意，现在是 AI Coding 的时代，所以我们的命题自然要考虑 AI 写出的代码以及 AI 写代码的过程。
我们将使用一种模仿数学公理体系的表述方式来进行分析，以便于我们自始至终明确区分“确定的结论”和“有待验证的判断”。当然，目前我们还做不到真正数学级的严谨，但这件事实在太过重要，所以我们可以先接受这种“近似严谨”，再不断迭代优化它。
为了让分析的过程更容易理解，我们会先给出“前 AI Coding 时代”的共识（定义和公理），然后分析在当下有哪些公理依然成立，而哪些已经动摇甚至被颠覆。">

<meta name="generator" content="Hugo 0.154.5">
    

  <link rel="stylesheet" href="/css/normalize.min.css" />
  <link rel="stylesheet" href="/fontawesome/css/all.min.css" />
  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  
  
  <link rel="stylesheet" type="text/css" href="/css/styles.css" /><link rel='stylesheet' href='/css/main.css'><link rel='stylesheet' href='/css/syntax.css'>
</head>

<body>
  <div id="container">
    <header>
      
      <h1>
        <a href="/">Paradigm X</a>
      </h1>

      <ul id="social-media">
      </ul>
      
      <p><em>Vision quests of a soulhacker</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="active" href="/posts/">
                <i class="fa-li fa  fa-lg"></i><span>全部文章</span>
            </a>
        </li>
        
        <li>
            <a class="" href="/tags/">
                <i class="fa-li fa  fa-lg"></i><span>标签</span>
            </a>
        </li>
        
        <li>
            <a class="" href="/about/">
                <i class="fa-li fa  fa-lg"></i><span>关于</span>
            </a>
        </li>
        
    </ul>
</nav>


    <main>




<article>

    <h1>什么是好的代码</h1>

    
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2026-01-11T00:00:00Z">Jan 11, 2026</time>
        </li>
        
        <li>
            Modified on <time datetime="2026-01-11T23:16:12&#43;08:00">Jan 11, 2026</time>
        </li>
        
        

        
        <li>
            <em>
                
                    
                    <a href="/tags/programming">#Programming</a>
                
            </em>
        </li>
        

        <li>2 minute read</li>
    </ul>
</aside>

    

    
      

    

    <p>本文将讨论一个简单又困难的命题：好代码的标准。注意，现在是 AI Coding 的时代，所以我们的命题自然要考虑 AI 写出的代码以及 AI 写代码的过程。</p>
<p>我们将使用一种模仿数学公理体系的表述方式来进行分析，以便于我们自始至终明确区分“确定的结论”和“有待验证的判断”。当然，目前我们还做不到真正数学级的严谨，但这件事实在太过重要，所以我们可以先接受这种“近似严谨”，再不断迭代优化它。</p>
<p>为了让分析的过程更容易理解，我们会先给出“前 AI Coding 时代”的共识（定义和公理），然后分析在当下有哪些公理依然成立，而哪些已经动摇甚至被颠覆。</p>
<h2 id="定义与问题域">定义与问题域</h2>
<h3 id="计算机软件">计算机软件</h3>
<p><strong>计算机软件</strong> <em>Computer Software</em> 是 <strong>代码</strong> 、 <strong>数据</strong> 及相关 <strong>文档</strong> 的集合，是与硬件相对的非有形部分，它们共同协作让计算机执行特定任务，满足用户的特定需求，是用户与硬件之间的桥梁。计算机软件的主要组成部分：</p>
<ul>
<li><strong>代码</strong> <em>Code</em> ：为完成特定功能而设计的指令序列，告诉硬件如何工作，也称为 <strong>程序</strong> <em>Programs</em> ，是本文讨论的核心对象。</li>
<li><strong>数据</strong> <em>Data</em> ：支持程序运行所需的信息。</li>
<li><strong>文档</strong> <em>Documentation</em> ：关于软件的开发、使用和维护说明，帮助用户理解和使用软件。</li>
</ul>
<h3 id="软件系统与软件模块">软件系统与软件模块</h3>
<p>当我们说 <strong>计算机软件</strong> ，通常是从外部视角，将软件作为一个整体看待；而当我们试图从内部视角看一个软件，我们会将其视为一个 <strong>系统</strong> <em>System</em> ，即所谓 <strong>软件系统</strong> <em>Software System</em> 。一个软件系统可由若干 <strong>子系统</strong> <em>Subsystem</em> 组成，而子系统又可由更小的子系统组成，子系统也可称为软件 <strong>模块</strong> <em>Module</em> 。</p>
<h3 id="软件规模与复杂度">软件规模与复杂度</h3>
<p>软件系统的 <strong>规模</strong> <em>Scale</em> 与 <strong>复杂度</strong> <em>Complexity</em> 是相关但不同的概念。</p>
<ul>
<li><strong>软件规模</strong> 通常指软件系统的代码行数、功能点数、用户数量、数据量等客观的规模性指标。</li>
<li><strong>软件复杂度</strong> 通常体现在维护和修改软件的代价或困难程度上。</li>
</ul>
<p>一般来说，软件规模越大，内部联系越复杂，复杂度通常也越高，体现在对软件的修改和验证代价上。但一个规模很大的软件系统也可以有较低的复杂度，如果它经过特定设计，使所有可能的修改都限定在一定范围内，且高度可验证的话。</p>
<h3 id="软件修改与验证">软件修改与验证</h3>
<p>无论增加、移除还是变更软件的功能，都只能通过对软件系统的修改实现。对此修改通常需要进行两方面的验证：</p>
<ul>
<li>修改确实实现了既定目标，即按照需求规格增加了新功能或移除、变更了旧功能。</li>
<li>修改没有影响需求规格以外的其它既有功能，这通常称为 <strong>回归验证</strong> <em>Regression Testing</em> 。</li>
</ul>
<h3 id="软件生命周期与版本迭代">软件生命周期与版本迭代</h3>
<p>软件 <strong>生命周期</strong> <em>Life-cycle</em> 指软件从概念形成到最终退役的完整过程，通常包括 <strong>软件定义</strong> 、 <strong>软件开发</strong> 和 <strong>软件维护</strong> 等阶段。</p>
<p>绝大部分软件还会有 <strong>版本迭代</strong> <em>Product Iteration</em> 的过程，新版本会继承旧版本生命周期（定义、开发、维护阶段）的所有成果（代码、数据和文档），在此基础上再经过定义、开发和维护阶段来完成自身的生命周期，进而被更新版本的生命周期所继承。</p>
<p>软件生命周期与迭代带来软件规模和复杂度的持续增加，直到旧软件被彻底废弃、完全重新构建新的替代软件为止。</p>
<h2 id="旧公理体系">旧公理体系</h2>
<p>接下来我们列出在“前 AI Coding 时代”被广泛实践验证的一些公理，包括关于软件开发根本性困难的四条公理（公理一至四）和关于控制软件规模与复杂度的三条公理（公理五至七）。</p>
<h3 id="公理一-需求变化公理">公理一：需求变化公理</h3>
<p>软件需求必然变化。软件需求在软件全生命周期中都可能变化，其不同阶段的变化可能性可以调控但无法消除。</p>
<h3 id="公理二-需求模糊公理">公理二：需求模糊公理</h3>
<p>未完成的软件的需求无法被完全描述。所有涉众在软件完全呈现并可使用之前无法完全统一对功能及非功能性需求的认知与表述。这里的“涉众”包括功能的各价值相关方和开发团队中的产品定义、开发等执行角色。</p>
<h3 id="公理三-复杂度公理">公理三：复杂度公理</h3>
<p>一次对软件系统的修改，其失败概率与对其进行验证的难度成正比。在工程实践中，“失败概率”可以看作与“复杂度”、“难度”、“代价”近似的概念。</p>
<p><strong>推论</strong> ：结合“软件修改与验证”定义可以推出，修改的失败概率受两方面影响：</p>
<ul>
<li>修改本身的复杂度，越复杂所需的验证就越难；</li>
<li>修改影响的范围，影响范围越大，所需进行的回归验证就越多、代价就越高。</li>
</ul>
<h3 id="公理四-成本公理">公理四：成本公理</h3>
<p>开发者的能力与潜在产出可能无法被准确量化。</p>
<p><strong>推论</strong> ：软件开发的成本和交付时间无法准确预估。</p>
<h3 id="软件工程的根本性困难">软件工程的根本性困难</h3>
<p>以上的定义及公理一至四指出了软件工程的根本性困难：需求的变化与模糊性决定了软件系统的修改是常态；软件系统的复杂度增长使每次修改的难度和代价不断增加。</p>
<p>在不断变化的需求和不断增长的系统规模前提下，如何控制系统的复杂度和每次修改的复杂度是软件工程中架构层面的核心挑战。</p>
<blockquote>
<p>软件工程中另外的两个核心挑战分别是：</p>
<ul>
<li>需求管理与控制：两个需求公理指出，杜绝需求的变化与模糊是不可能的，但可以通过一定的控制措施使其更可控。</li>
<li>资源调度、计划与风险控制：成本公理指出这同样不可能完全精确，但同样可以通过一定的控制措施将风险与误差控制在一定范围内。</li>
</ul>
<p>后面这两个挑战与本文主旨没有直接关联，所以不会深入讨论，只在需要时提及。</p>
</blockquote>
<p>在“前 AI Coding 时代”，对系统复杂度及修改复杂度的控制，主要依靠的是软件代码的架构设计，即良好的“模块化”：如果我们能把复杂的软件系统设计为一个个独立的模块，每个模块可以独立地定义、开发与验证，模块与模块之间仅通过定义良好的接口进行交互，那么即使系统总的规模非常巨大，每次修改的影响也能限制在少数几个模块内，其复杂度和正确性就可控。</p>
<p>一直以来，构建大规模无错软件系统的希望，就在于通过模块化实现增量式构建：先积累小的、充分验证过的无错模块，通过组合这些模块来形成更大的模块，以及更大的模块……已经验证过的模块在系统扩大的过程中无需再次验证，这样就能维持以可控的代价建立越来越大的无错系统。</p>
<p>而实现这一点的前提是保证“模块化”的核心要求：高内聚，低耦合，以及良好的交互接口。也就是下面三条公理。</p>
<h3 id="公理五-内聚公理">公理五：内聚公理</h3>
<p>一个软件模块应专注于一个单一的、明确的功能或职责。如果不是这样，可以拆分成更多模块。</p>
<h3 id="公理六-耦合公理">公理六：耦合公理</h3>
<p>模块之间相互依赖的程度应尽可能低，理想状况下一个模块不应依赖于任何其他模块的内部实现，而只通过接口互相协作。</p>
<h3 id="公理七-接口公理">公理七：接口公理</h3>
<p>软件模块应提供定义良好的、供其他程序模块使用的接口；定义良好的接口应尽量满足：</p>
<ul>
<li><strong>责任分离</strong> <em>Separation of Concerns</em> ：接口只暴露必要功能，而隐藏其内部实现细节，调用方只与其交互。</li>
<li><strong>稳定</strong> <em>Stability</em> ：一旦投入使用，接口不应轻易修改，如需要新增功能，应定义新接口，而不是改动旧的。</li>
<li><strong>不可变</strong> <em>Immutability</em> ：不应修改接口传入的数据或状态，而所有 <strong>副作用</strong> <em>Side Effect</em> 应局限在模块内。</li>
<li><strong>契约化</strong> <em>Contract Based</em> ：定义清晰的数据类型、函数、参数、返回值、异常等，形成一个完备的契约，如可能应与实现无关。</li>
</ul>
<h3 id="控制复杂度">控制复杂度</h3>
<p>公理五至七合起来，定义了一个强有力的约束，使满足约束的软件模块成为真正高质量的软件“积木”，可以放心地用于组合、构建复杂的软件系统；也使软件构建过程中每一步的复杂度都可控，因为我们总是可以通过分而治之的策略，将每一次修改限制在足够少、足够小的模块内，对其他模块的影响可以忽略，验证起来代价也就足够可控。</p>
<h2 id="前-ai-coding-时代的标准">前 AI Coding 时代的标准</h2>
<p>在“前 AI Coding 时代”，对“好代码”的评价标准，很大程度上源于上面的定义和公理体系，大体可以分为几个方面：</p>
<ul>
<li>基本
<ul>
<li>正确</li>
<li>安全与容错</li>
<li>性能与效率</li>
</ul>
</li>
<li>复杂度控制
<ul>
<li>模块化</li>
<li>易于测试与验证</li>
<li>易于扩展与变更</li>
</ul>
</li>
<li>团队协作
<ul>
<li>清晰易读</li>
<li>一致风格与约定</li>
<li>文档化</li>
</ul>
</li>
</ul>
<p>我们通常会使用一系列测试方法来确保软件的正确、安全和性能；通过代码评审和其他相关软件工程实践来确保代码架构符合模块化要求，使得对软件修改和验证的复杂度不超出可控范围；通过软件工程的过程规范来降低在长期多人协作过程中形成的人为损耗。如果这三方面都能保持得很好，那么软件项目就不会失控。</p>
<p>那么，在“AI Coding 时代”，这些结论还成立吗？</p>
<h2 id="ai-coding-时代的不变量">AI Coding 时代的不变量</h2>
<p>在这个新的时代，由 <strong>大语言模型</strong> <em>Model</em> 、模型可调用的 <strong>工具</strong> <em>Tools</em> 和人类的 <strong>指令</strong> <em>Instruction</em> 共同组成了 <strong>智能体系统</strong> <em>Agentic System</em> ，帮助我们完成各种软件开发工作。下面我们会用 <strong>智能体</strong> <em>Agent</em> 来代表这样的人工智能体系统。</p>
<p>可能你已经发现了，在 <em>Agent</em> 给软件工程领域带来的巨大改变背后，保持着一些关键的不变量，例如：</p>
<ul>
<li>由于定义和使用软件的基本逻辑并未发生变化，所以关于软件的基本定义没有变化，人类仍然是软件定义的最终决策人和责任人。</li>
<li>由于目前 <em>Agent</em> 尚无法生成可自证的软件系统，所以关于软件验证的定义没有变化，人类仍然是验证软件修改和验收的责任人。</li>
</ul>
<p>相比这些确定的不变量，还有一些比较复杂的维度，我们下面重点讨论其中两个。</p>
<h3 id="代码模块化与可维护性">代码模块化与可维护性</h3>
<p>一个关键且有些复杂的问题是：控制软件系统和每次修改迭代的复杂度还有那么重要吗？这个问题的答案直接影响代码的模块化要求是不是不变量的认定。由于大语言模型的能力还在快速演进中，对超长上下文的处理能力完全有可能在可预见的未来得到显著加强，强到可以一次读取和理解整个 <em>codebase</em> （对大部分规模的软件项目），所以我们对这个问题尚无法完全下定论，但基于下面几点，我们认为控制复杂度仍然是代码质量中的关键分量：</p>
<ul>
<li>大语言模型能处理超大量的上下文，并不代表能非常高效地处理，可能带来飙升的成本和下降的质量，在小而精的上下文中工作，在很长时间里仍将是最高效的方式（从时间和金钱两个层面）。</li>
<li>在很长一段时间里，复杂的软件系统和现有的软件系统仍然需要人类与 <em>Agent</em> 共同维护，良好的模块化设计是人类（参与）维护软件系统的前提条件；在复杂系统上排错也是目前离不开人类的一个场景。</li>
<li>模块化代码更容易测试，我们可以更快更好地测试独立的小模块，而非整个巨大的系统； <em>Agent</em> 可以生成代码，但验证和测试仍需测试框架，如果代码不模块化，故障隔离会变得困难，导致后续的修复和修改更容易出错。</li>
<li>模块化代码更容易复用，而久经考验的可复用代码可以大幅提升 <em>Agent</em> 的生成效率。</li>
<li>由于 <em>Agent</em> 生成代码的效率远高于人类，即使维持模块化设计及拆分更多任务 <em>iteration</em> 需要花费一些时间，但只要能降低失败率，少返工，产出效率仍可比上一个时代提升一个数量级，足够好了。</li>
</ul>
<p>目前大部分 <em>Agent</em> 并不会非常主动的进行模块化设计，所以定期进行模块化重构是当下最有价值的最佳实践之一。这类重构本身难度不大，成功率较高，而收益很大，可以控制系统总体复杂度，对齐与 <em>Agent</em> 关于代码架构的认知，形成长期有效的文档等。</p>
<h3 id="代码可读性与文档化">代码可读性与文档化</h3>
<p>和很多人的直觉可能不一样，代码的可读性以及文档化对 <em>Agent</em> 来说仍然很重要，某种意义上可能比对人类还重要。具体体现在：</p>
<ul>
<li>大语言模型本质上是语言理解与生成的工具，在 <em>Coding Agent</em> 的工作场景中，正确理解复杂的上下文是成功的基础，而代码本身携带的有价值信息（良好的命名规则、模块划分、函数定义、注释等等）越多，越能帮助模型生成正确的代码；而误导性的成分越多，越容易造成模型的误解与错判。</li>
<li>以人为主的工程通常追求团队的稳定，但我们经常更换 <em>Agent</em> 工具， <em>Agent</em> 也不具备人类那样的长期记忆与稳定风格，所以更需要通过标准化代码风格和专门的约束文档来弥补。</li>
<li>如果是人类与 <em>Agent</em> 共同维护的代码，我们可以通过一些特殊约定的标签来限制和规范 <em>Agent</em> 行为，比如通过特殊的注释标注保护不可更改的代码片段。</li>
</ul>
<p>与建立专用文档与 <em>Agent</em> 互动相比，在代码中适用良好的风格，配合精心设计的协作标签，能更经济的使用上下文（因为 <em>Agent</em> 通常只访问与任务有关的片段），也符合人类维护代码的习惯。</p>
<h2 id="ai-coding-时代的增量">AI Coding 时代的增量</h2>
<p>大量由 <em>Agent</em> 生成的代码带来新的问题，也带来对代码新的要求，这里面最突出的是软件（自动化）验证的一些需求：</p>
<ul>
<li>开发环境安全： <em>Agent</em> 在开发过程中可能访问本地资源，可能访问（不安全）的网页，可能运行各种本地命令，这里面有巨大的安全隐患，非常需要一种安全强化但依然足以完成开发任务的环境；现有的虚拟化和沙箱技术足以支撑这样的环境，但需要良好的整合和产品化。</li>
<li>代码运行安全：目前绝大部分情况下 <em>Agent</em> 不能确保生成代码的安全性，由于信息安全领域的特殊性，似乎也很难通过学习代码素材来解决这个问题，可能的一个路线是开发针对 <em>Agent</em> 生成代码的安全与可靠性扫描与检测工具，并将其融入 <em>Agent</em> 的标准工作流程中。</li>
<li>更高效的软件验证流程：无论怎么控制复杂度，只能提升总体效率，不能确保最终交付系统的正确性，完备、高效、分层渐进的软件测试和验证仍是最后的关键节点，如前所述，如果我们给 <em>Agent</em> 生成代码的模块化与文档化提出一些强制要求，也许可以对此过程的自动化带来一些更好的机会。</li>
</ul>
<p>这些问题其实一直都有，但由于人类生产代码的速度远不及现在（和可预见未来）的 <em>Coding Agent</em> ，所以在这个时代，这些需求变得更加重要甚至紧迫。</p>
<p>在大量自动化验证工具的帮助下，也许就能实现更好的人类与 <em>Agent</em> 间的分工，并推进代码双重 <em>Owner</em> 等全新的分工、责任与协同体系，把我们更快引向 <strong>软件工程 2.0</strong> 。</p>
<h2 id="结论">结论</h2>
<p>通过以上的分析，我们可以得到如下判断：</p>
<ul>
<li>软件开发的基本范式还没有大的变化，软件工程中的核心问题（渐进式定义、复杂度控制、测试与验证）依然是我们面对的主要挑战。</li>
<li>本文前半部分的定义和定理体系仍然成立，只在一些具体细节上需要进行新的解读。</li>
<li>进入 <em>Coding Agent</em> 时代后，通过良好的代码架构来控制复杂度仍然非常重要，仍是最具效率的最佳实践；代码可读性和文档化的要求甚至高于过去；而对软件系统的测试与验证是亟待创新与突破的领域。</li>
</ul>
<p>如此看来，在这个新的时代，好代码的标准并没有太大的变化；未来可能最大的变化是通过更可靠、高效的测试验证系统取代细致的代码评审，从而可以在软件系统总体复杂度受控的前提下忽略对代码细节的追求。</p>

</article>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css"
    integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js"
    integrity="sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false }
            ]
        });
    });
</script>


<section class="post-nav">
    <ul>
        <li>
        
            <a href="/posts/bridge-17/"><i class="fa fa-chevron-circle-left"></i> 自然叫牌法和防守系统（十七队）</a>
        
        </li>
        <li>
        
            <a href="/posts/why-type-system-matters/">为什么你要学习类型系统 <i class="fa fa-chevron-circle-right"></i> </a>
        
        </li>
    </ul>
</section>
  
    
    
  





</main>
    <footer>
        <ul>
            <li>
                <h6>Copyright © 2024 - Neo Lee | 
                    Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
                    <a href="/index.xml">Subscribe </a></h6>
            </li>
            
            
        </ul>
    </footer>
</div>
<script src="/js/scripts.js"></script>

  


</body>

</html>

